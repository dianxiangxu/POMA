options
{
  static = true;
}

PARSER_BEGIN(FOLGrammar)
package POMA.Verification.ReachabilityAnalysis.fol.parser;
import POMA.Verification.ReachabilityAnalysis.fol.model.connectives.*;
import POMA.Verification.ReachabilityAnalysis.fol.model.predicates.*;
import POMA.Verification.ReachabilityAnalysis.fol.model.terms.*;
import POMA.Verification.ReachabilityAnalysis.fol.model.IFormula;
import java.util.ArrayList;
import java.util.List;

/**
 * Parser for queries NGAC.
 * 
 * Syntax: variables start with ?, predicates and constants
 * with either letters or digits. 
 * The binary operators "AND", "OR" must be put in parentheses; Predicates have parentheses for parameters.
 * The negation operator is "NOT". Comma is used as a delimiter for predicate parameters
 * The input has to end with ";"
 * 
 * TODO: "EXISTS" - needs to be added
 * < formula > ::=  < predicate > | < binary > | <negation> {, formula} ";"
 * < binary > :==  "(" < formula > "AND" < formula > ")"
 *          		| "(" < formula > "OR" < formula > ")"
 * < negation > :== "NOT" "(" < formula > ")"
 * < predicate > ::=  < PERMIT > | < ASSOCIATE > | < DENY > | < EXPLICITASSIGN > | < ASSIGN >
 * < PERMIT >  ::=  "PERMIT" "("< term > < term > < term >")"
 * < ASSOCIATE > ::=  "ASSOCIATE""(" < term > < term > < term >")"
 * < DENY > ::= "DENY""(" < term > < term > < term >")"
 * < EXPLICITASSIGN > "EXPLICITASSIGN""(" ::=  < term > < term >")"
 * < ASSIGN > ::=  "ASSIGN""(" < term > < term >")"
 * < HIERARCHY > ::= "HIERARCHY""(" < term > < term >")"
 * < term >  ::= CONST | VAR
 *
 * @author Vladislav Dubrovenski
 */

public class FOLGrammar
{
  public static void main(String args []) throws ParseException
  {
    FOLGrammar parser = new FOLGrammar(System.in);
    while (true)
    {
      System.out.println("Reading from standard input...");
      System.out.print("Enter an expression: ");
      try
      {
        IFormula f = FOLGrammar.parse();
        System.out.println(f);
      }
      catch (Exception e)
      {
        System.out.println("NOK.");
        System.out.println(e.getMessage());
        FOLGrammar.ReInit(System.in);
      }
      catch (Error e)
      {
        System.out.println("Oops.");
        System.out.println(e.getMessage());
        break;
      }
    }
  }
}

PARSER_END(FOLGrammar)

SKIP :
{
  " "
| "\r"
| "\t"
| "\n"
}

//punctuation
TOKEN :
{
  < OPEN : "(" >
| < CLOSE : ")" >
| < COMMA : "," >
| < QUESTION : "?" >
}

//built-in predicates
TOKEN :
{
  < PERMIT : "PERMIT" >
| < DENY : "DENY" >
| < EXPLICITASSIGN : "EXPLICITASSIGN" >
| < ASSIGN : "EXPLICIT" >
| < ASSOCIATE : "ASSOCIATE" >
| < HIERARCHY : "HIERARCHY" >
}

//logical connectives
TOKEN :
{
  < OR : "OR" >
| < AND : "AND" >
| < NOT : "NOT" >
}

//terms
TOKEN :
{
  < CONST : (< IDENTIFIER >)+ >
| < VAR : < QUESTION > (< IDENTIFIER >)+ >
| < #IDENTIFIER : [ "a"-"z", "A"-"Z", "0"-"9" ] >
}

IFormula parse() :
{
  IFormula f;
}
{
  f = formula() ";"
  {
    return f;
  }
}

ITerm term() :
{
}
{
  < CONST >
  {
    return new Constant(token.image);
  }
| < VAR >
  {
    return new Variable(token.image);
  }
}

IPredicate getPredicate() :
{
}
{
  < PERMIT >
  {
    return new PermitPredicate();
  }
| < DENY >
  {
    return new DenyPredicate();
  }
| < EXPLICITASSIGN >
  {
    return new ExplicitAssignPredicate();
  }
| < ASSIGN >
  {
    return new AssignPredicate();
  }
| < ASSOCIATE >
  {
    return new AssociatePredicate();
  }
| < HIERARCHY >
  {
    return new HierarchyPredicate();
  }
}

IPredicate predicate() :
{
  List < ITerm > tuple = new ArrayList < ITerm > ();
  IPredicate predicate;
  ITerm t;
}
{
  predicate = getPredicate()
  {
  }
  < OPEN > 
  t = term()
  {
    tuple.add(t);
  }
  (
    < COMMA > t = term()
    {
      tuple.add(t);
    }
  )*
  < CLOSE >
  {
    predicate.setTuple(tuple);
    return predicate;
  }
}

IFormula binary() :
{
  IFormula subformulaA, subformulaB;
}
{
  < OPEN > 
  subformulaA = formula()
  (
    < OR > 
    subformulaB = formula() 
    < CLOSE >
    {
      return new Disjunctive(subformulaA, subformulaB);
    }
  | 
    < AND > 
    subformulaB = formula() 
    < CLOSE >
    {
      return new Conjunctive(subformulaA, subformulaB);
    }
  )
}

IFormula negation() :
{
  IFormula subformula;
}
{
  < NOT > 
  < OPEN > 
  subformula = formula() 
  < CLOSE >
  {
    return new Negation(subformula);
  }
}

IFormula formula() :
{
  IFormula form;
}
{
  (
    form = predicate()
  | form = binary()
  | form = negation()
  )
  {
    return form;
  }
}
